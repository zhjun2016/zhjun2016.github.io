<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL学习 | 逆风而行的蟋蟀</title><meta name="author" content="ajun"><meta name="copyright" content="ajun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL学习图形管理界面工具Navicat安装与使用 SQLyong安装与使用 mysql入门到精通 概况sql简图  数据库   名称 全称 简称    数据库 存储数据的仓库，数据是有组织的进行存储 DataBase（DB）   数据库管理系统 操纵和管理数据库的大型软件 DataBase Management System (DBMS)   SQL 操作关系型数据库的编程语言，定义">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习">
<meta property="og:url" content="https://zhjun2016.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="逆风而行的蟋蟀">
<meta property="og:description" content="MySQL学习图形管理界面工具Navicat安装与使用 SQLyong安装与使用 mysql入门到精通 概况sql简图  数据库   名称 全称 简称    数据库 存储数据的仓库，数据是有组织的进行存储 DataBase（DB）   数据库管理系统 操纵和管理数据库的大型软件 DataBase Management System (DBMS)   SQL 操作关系型数据库的编程语言，定义">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-23T02:26:53.000Z">
<meta property="article:modified_time" content="2023-04-24T05:38:48.914Z">
<meta property="article:author" content="ajun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhjun2016.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-24 13:38:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="逆风而行的蟋蟀"><span class="site-name">逆风而行的蟋蟀</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-24T05:38:48.914Z" title="更新于 2023-04-24 13:38:48">2023-04-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />



<h2 id="MySQL学习"><a href="#MySQL学习" class="headerlink" title="MySQL学习"></a>MySQL学习</h2><h3 id="图形管理界面工具"><a href="#图形管理界面工具" class="headerlink" title="图形管理界面工具"></a>图形管理界面工具</h3><p>Navicat安装与使用</p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/209862.htm">SQLyong安装与使用</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.xn2001.com/archives/677.html">mysql入门到精通</a></strong></p>
<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p><strong>sql简图</strong></p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20220927153935675.png" alt="image-20220927153935675"></p>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">全称</th>
<th align="left">简称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据库</td>
<td align="left">存储数据的仓库，数据是有组织的进行存储</td>
<td align="left">DataBase（DB）</td>
</tr>
<tr>
<td align="left">数据库管理系统</td>
<td align="left">操纵和管理数据库的大型软件</td>
<td align="left">DataBase Management System (DBMS)</td>
</tr>
<tr>
<td align="left">SQL</td>
<td align="left">操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td>
<td align="left">Structured Query Language (SQL)</td>
</tr>
</tbody></table>
<h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><p>关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。<br>而所谓二维表，指的是由行和列组成的表，可以通过一列关联另外一个表格中的某一列数据，如下图。</p>
<p>特点：</p>
<ol>
<li>使用表存储数据，格式统一，便于维护。</li>
<li>使用 SQL 语言操作，标准统一，使用方便。</li>
</ol>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20220927154417777.png" alt="image-20220927154417777"></p>
<p>常见的 MySQL、Oracle、DB2、SQLServer 这些都是属于关系型数据库，里面都是基于二维表存储数据的。</p>
<p>无论我们使用哪一个关系型数据库，最终在操作时都是使用 SQL 语言来进行统一操作，<br>因为我们接下来学习的 SQL 语言，是操作关系型数据库的统一标准。</p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20220927154516387.png" alt="image-20220927154516387"></p>
<h5 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h5><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准。</p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20220927155137877.png" alt="image-20220927155137877"></p>
<ol>
<li>SQL 语句可以单行或多行书写，以分号结尾。</li>
<li>SQL 语句可以使用空格&#x2F;缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，<strong>关键字建议使用大写</strong>。</li>
<li>注释：<ol>
<li>单行注释：– 注释内容 或 # 注释内容</li>
<li>多行注释：&#x2F; <em>注释内容</em> &#x2F;</li>
</ol>
</li>
</ol>
<p>SQL 语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DDL</td>
<td align="left">数据定义语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr>
<td align="left">DML</td>
<td align="left">数据操作语言,用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td align="left">DQL</td>
<td align="left">数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td align="left">DCL</td>
<td align="left">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody></table>
<h3 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a><strong>SQL基础</strong></h3><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a><strong>DDL</strong></h5><blockquote>
<p>​	数据定义语言，定义数据库对象(数据库，表，字段)</p>
</blockquote>
<h6 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a><strong>数据库操作</strong></h6><p>查询所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES</span><br></pre></td></tr></table></figure>

<p>使用某个数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p>查询当前数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<p>创建数据库</p>
<blockquote>
<p>UTF8 字符集长度为3字节，有些符号占4字节，所以创建数据库时推荐用 utf8mb4 字符集</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] 数据库名;</span><br></pre></td></tr></table></figure>

<h6 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a><strong>数据表操作</strong></h6><p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(    </span><br><span class="line">	字段1 字段1类型 [COMMENT 字段1注释],    </span><br><span class="line">	字段2 字段2类型 [COMMENT 字段2注释],    </span><br><span class="line">	字段3 字段3类型 [COMMENT 字段3注释],    </span><br><span class="line">	...    </span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释] </span><br><span class="line">	)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure>

<p><strong>最后一个字段后面是没有逗号的。</strong></p>
<p>查询表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<p>查询当前数据库所有表，<strong>必须处在数据库中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>查询某表的建表语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>表中添加字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"></span><br><span class="line">-- 例如 ALTER TABLE emp ADD nickname varchar(20) COMMENT &#x27;用户昵称&#x27;;</span><br></pre></td></tr></table></figure>

<p>修改数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); </span><br><span class="line">-- 例如 ALTER TABLE emp MODIFY nickname varchar(30);</span><br></pre></td></tr></table></figure>

<p>修改字段名和字段类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line">-- 例如</span><br><span class="line">ALTER TABLE emp CHANGE nickname name varchar(40);</span><br></pre></td></tr></table></figure>

<p>删除字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名; </span><br><span class="line">-- 例如 ALTER TABLE emp drop nickname;</span><br></pre></td></tr></table></figure>

<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名; </span><br><span class="line">-- 例如 ALTER TABLE emp RENAME TO empNew;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名; </span><br><span class="line">-- 例如 DROP TABLE [IF EXISTS] emp;</span><br></pre></td></tr></table></figure>

<p>删除表，并重新创建该表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line"> -- 例如 TRUNCATE TABLE emp;</span><br></pre></td></tr></table></figure>



<h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a><strong>DML</strong></h5><blockquote>
<p>数据操作语言，用来对数据库表中的数据进行增删改</p>
<p>字符串和日期类型数据应该包含在引号中</p>
<p>插入的数据大小应该在<strong>字段的规定范围</strong>内</p>
</blockquote>
<p>指定字段添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>



<h5 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a><strong>DQL</strong></h5><blockquote>
<p>数据查询语言，用来查询数据库中表的记录</p>
</blockquote>
<h6 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a><strong>基础查询</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT    </span><br><span class="line">		字段列表 </span><br><span class="line">FROM    </span><br><span class="line">		表名字段 </span><br><span class="line">WHERE    </span><br><span class="line">		条件列表 </span><br><span class="line">GROUP BY   </span><br><span class="line">		分组字段列表 </span><br><span class="line">HAVING    </span><br><span class="line">		分组后的条件列表 </span><br><span class="line">ORDER BY    </span><br><span class="line">		排序字段列表 </span><br><span class="line">LIMIT    </span><br><span class="line">		分页参数</span><br></pre></td></tr></table></figure>

<p>查询所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名;  </span><br><span class="line"></span><br><span class="line">-- 实际开发中尽量不要写 * 而是建议把每个字段都写出来 SELECT id,name,age... FROM emp;</span><br></pre></td></tr></table></figure>

<p>查询结果字段带别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; </span><br><span class="line">SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</span><br></pre></td></tr></table></figure>

<p>去除重复记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure>

<h6 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure>

<p>条件列表</p>
<table>
<thead>
<tr>
<th align="left">比较运算符</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt; 或 !&#x3D;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">BETWEEN … AND …</td>
<td align="left">在某个范围内（含最小、最大值）</td>
</tr>
<tr>
<td align="left">IN(…)</td>
<td align="left">在in之后的列表中的值，多选一，或的意思</td>
</tr>
<tr>
<td align="left">LIKE 占位符</td>
<td align="left">模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td align="left">IS NULL</td>
<td align="left">是NULL</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">逻辑运算符</th>
<th align="left">功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND 或 &amp;&amp;</td>
<td align="left">并且（多个条件同时成立）</td>
<td></td>
</tr>
<tr>
<td align="left">OR 或 \</td>
<td align="left">\</td>
<td>或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td align="left">NOT 或 !</td>
<td align="left">非，不是</td>
<td></td>
</tr>
</tbody></table>
<p><strong>在mybatis的mapper.xml里使用 大于等于或者小于等于</strong></p>
<p>解决方案一：使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020">转义</a>字符</p>
<blockquote>
<p>&lt; &#x2F;&#x2F;小于(&lt;)<br>&gt; &#x2F;&#x2F;大于(&gt;)<br>&amp;le; &#x2F;&#x2F;小于或等于(≤)<br>&amp;ge; &#x2F;&#x2F; 大于或等于(≥)</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>十进制</th>
<th>转义字符</th>
</tr>
</thead>
<tbody><tr>
<td>“</td>
<td>“</td>
<td>&quot;</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>不断开空格(non-breaking space)</td>
<td></td>
<td><pre>&nbsp;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><select id="findByUserId"resultMap="BaseResultMap"parameterType="java.lang.String" ><br>   select<br>  <include refid="Base_Column_List" /><br>  from t_user<br>  where user_id = #{userId} and status &lt;&gt;0<br></select></p>
<p>解决方案二：<![CDATA[ ]]></p>
<p>大于等于 <![CDATA[>= ]]></p>
<p>小于等于   <![CDATA[<= ]]></p>
<p>不等于  ]]>  <![CDATA[<> ]]></p>
<p>示例：</p>
<select id="findByUserId" resultMap="BaseResultMap" parameterType="java.lang.String" >
    select
    <include refid="Base_Column_List" />
    from t_user
    where user_id = #{userId} and status <![CDATA[ <> ]]> 0
</select>


<p>练习</p>
<details>
select * from emp where age = 30; 
-- 没有身份证 select * from emp where idcard is null or idcard = ''; 
-- 有身份证
select * from emp where idcard; 
select * from emp where idcard is not null; 
-- 不等于 
select * from emp where age != 30; 
-- 年龄在20到30之间 
select * from emp where age between 20 and 30; 
select * from emp where age >= 20 and age <= 30; 
-- 下面语句不报错，但查不到任何信息，因此一定要从先写小再写大 
select * from emp where age between 30 and 20; 
-- 性别为女且年龄小于30 
select * from emp where age < 30 and gender = '女';
 -- 年龄等于25或30或35 
select * from emp where age = 25 or age = 30 or age = 35; 
select * from emp where age in (25, 30, 35); 
-- 姓名为两个字 
select * from emp where name like '__'; 
-- 姓名第一个字为钟 
select * from emp where name like '钟%'; 
-- 姓名最后第一个字为雪 
select * from emp where name like '%雪'; 
-- 身份证最后为X 
select * from emp where idcard like '%X';
</details>
 

<h6 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h6><blockquote>
<p>   将一列数据作为一个整体，进行纵向计算。直接作用于字段。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名;</span><br></pre></td></tr></table></figure>

<p>​    常见聚合函数如下，注意：所有 null 值不参与聚合运算。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">count</td>
<td align="left">统计数量</td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">最大值</td>
</tr>
<tr>
<td align="left">min</td>
<td align="left">最小值</td>
</tr>
<tr>
<td align="left">avg</td>
<td align="left">平均值</td>
</tr>
<tr>
<td align="left">sum</td>
<td align="left">求和</td>
</tr>
</tbody></table>
<p>练习</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 统计企业员工数量 select count(id) from emp; </span><br><span class="line">-- 统计企业平均年龄 select avg(age) from emp; </span><br><span class="line">-- 统计西安地区员工的年龄之和 select sum(age) from emp where workaddr = &#x27;西安&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>分组查询</strong>        </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</span><br></pre></td></tr></table></figure>

<p>分组往往伴随着聚合</p>
<blockquote>
<p>where 和 having 的区别：</p>
<ul>
<li>执行时机不同：where 是分组之前进行过滤，不满足 where 条件不参与分组；having 是分组后对结果进行过滤。</li>
<li>判断条件不同：where 不能对聚合函数进行判断，而 having 可以。</li>
</ul>
</blockquote>
<p>注意：</p>
<ul>
<li>执行顺序：where > 聚合函数 > having</li>
<li>分组之后，<strong>查询的字段一般为聚合函数和分组字段</strong>，查询其他字段无任何意义</li>
</ul>
<p><strong>练习</strong>       </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">    select count(*) from emp group by gender; </span><br><span class="line"></span><br><span class="line">-- 根据性别分组，统计男性和女性数量 </span><br><span class="line"></span><br><span class="line">*select gender, count(*) from emp group by gender; </span><br><span class="line"></span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄 </span><br><span class="line"></span><br><span class="line">select gender, avg(age) from emp group by gender; </span><br><span class="line"></span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量 </span><br><span class="line"></span><br><span class="line">select workaddr, count(*) from emp where age &lt; 45 group by workaddr; </span><br><span class="line"></span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 </span><br><span class="line"></span><br><span class="line">*select workaddr, count(*) address_count from emp where age &lt; 45 group by workaddr having address_count &gt;= 3;</span><br></pre></td></tr></table></figure>

<p>排序查询</p>
<p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</span><br></pre></td></tr></table></figure>

<p>排序方式</p>
<ul>
<li>ASC：升序（默认）</li>
<li>DESC：降序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 根据年龄升序排序 select * from emp order by age ASC; </span><br><span class="line">select * from emp order by age; </span><br><span class="line">-- 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序 </span><br><span class="line">select * from emp order by age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure>

<p>分页查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure>

<ul>
<li>起始索引从0开始，所以这里有个公式，起始索引 = (查询页码 - 1) * 每页显示记录数</li>
<li><strong>分页查询是数据库的方言，不同数据库有不同实现，MySQL 是 LIMIT</strong></li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条 </span><br><span class="line">select * from emp limit 0, 10; </span><br><span class="line">-- 查询第二页，每页展示10条 </span><br><span class="line">select * from emp limit 10, 10;</span><br></pre></td></tr></table></figure>

<h6 id="DQL练习"><a href="#DQL练习" class="headerlink" title="DQL练习"></a>DQL练习</h6><blockquote>
<p>DQL 编写顺序：</p>
<p>SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> LIMIT</p>
<p>DQL 执行顺序：</p>
<p>FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT</p>
</blockquote>
<blockquote>
<p><img src="https://cdn.xn2001.com/img/2022/202205041211635.png" alt="img"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 1．查询年龄为20,21,22,23岁的员工信息。 </span><br><span class="line">select * from emp where age in(20,21,22,23); </span><br><span class="line">-- 2．查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工。 </span><br><span class="line">select * from emp where gender = &#x27;男&#x27; and age between 20 and 40 and name like &#x27;___&#x27;; </span><br><span class="line">-- 3．统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。 select gender, count(*) from emp where age &lt; 60 group by gender; </span><br><span class="line">-- 4．查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。 </span><br><span class="line">select name, age from emp where age &lt; 35 order by age ASC, entrydata DESC; </span><br><span class="line">-- 5、查询性别为男，且年龄在20-40岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。 </span><br><span class="line">select * from emp where (gender = &#x27;男&#x27;) and (age &gt;= 20 and age &lt;=40) order by age ASC,entrydata DESC limit 5;</span><br></pre></td></tr></table></figure>




<h5 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a><strong>DCL</strong></h5><blockquote>
<p>数据控制语言，用来创建数据库用户、控制数据库的访问权限</p>
</blockquote>
<h6 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h6><p>查询用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql; </span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<p>创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>修改用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>删除用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户lxh，只能在当前主机localhost访问 </span><br><span class="line">create user &#x27;lxh&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line">-- 创建用户test，能在任意主机访问，使用 % 通配符号 </span><br><span class="line">create user &#x27;lxh&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; create user &#x27;lxh&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line">-- 修改密码 </span><br><span class="line">alter user &#x27;lxh&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123&#x27;; </span><br><span class="line">-- 删除用户 </span><br><span class="line">drop user &#x27;lxh&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<h6 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h6><p>常见的权限如下，<strong>更具体</strong>需百度</p>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ALL, ALL PRIVILEGES</td>
<td align="left">所有权限</td>
</tr>
<tr>
<td align="left">SELECT</td>
<td align="left">查询数据</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="left">插入数据</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="left">修改数据</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除数据</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="left">修改表</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="left">删除数据库/表/视图</td>
</tr>
<tr>
<td align="left">CREATE</td>
<td align="left">创建数据库/表</td>
</tr>
</tbody></table>
<p>-- 查询权限：</p>
<p> SHOW GRANTS FOR '用户名'@'主机名'; </p>
<p>-- 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; </p>
<p>-- 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';</p>
<p> -- 注意：   </p>
<p>​		 -- 多个权限用逗号分隔    </p>
<p>​		-- 授权时，数据库名和表名可以用 * 进行通配，代表所有</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h4><p>函数是指一段可以直接被另一段程序调用的程序或代码。</p>
<h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><p>常用的字符串函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONCAT(s1, s2, …, sn)</td>
<td align="left">字符串拼接，将s1, s2, …, sn拼接成一个字符串</td>
</tr>
<tr>
<td align="left">LOWER(str)</td>
<td align="left">将字符串全部转为小写</td>
</tr>
<tr>
<td align="left">UPPER(str)</td>
<td align="left">将字符串全部转为大写</td>
</tr>
<tr>
<td align="left">LPAD(str, n, pad)</td>
<td align="left">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="left">RPAD(str, n, pad)</td>
<td align="left">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="left">TRIM(str)</td>
<td align="left">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td align="left">SUBSTRING(str, start, len)</td>
<td align="left">返回从字符串str从start位置起的len个长度的字符串，起始索引为1</td>
</tr>
</tbody></table>
<p>案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员 工的工号应该为00001。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update emp set workno = LPAD(workno,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h5 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a><strong>数值函数</strong></h5><p>常用的数值函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CEIL(x)</td>
<td align="left">向上取整</td>
</tr>
<tr>
<td align="left">FLOOR(x)</td>
<td align="left">向下取整</td>
</tr>
<tr>
<td align="left">MOD(x, y)</td>
<td align="left">返回x/y的模</td>
</tr>
<tr>
<td align="left">RAND()</td>
<td align="left">返回0~1内的随机数</td>
</tr>
<tr>
<td align="left">ROUND(x, y)</td>
<td align="left">求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<p>案例：通过数据库的函数，生成一个六位数的随机验证码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 通过rand()获取0~1，乘以1000000，通过四舍五入即可。如果未满6位，则补0 </span><br><span class="line">select lpad(round(rand()*1000000, 0), 6, &#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a><strong>日期函数</strong></h5><p>常用日期函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CURDATE()</td>
<td align="left">返回当前日期</td>
</tr>
<tr>
<td align="left">CURTIME()</td>
<td align="left">返回当前时间</td>
</tr>
<tr>
<td align="left">NOW()</td>
<td align="left">返回当前日期和时间</td>
</tr>
<tr>
<td align="left">YEAR(date)</td>
<td align="left">获取指定date的年份</td>
</tr>
<tr>
<td align="left">MONTH(date)</td>
<td align="left">获取指定date的月份</td>
</tr>
<tr>
<td align="left">DAY(date)</td>
<td align="left">获取指定date的日期</td>
</tr>
<tr>
<td align="left">DATE_ADD(date, INTERVAL expr type)</td>
<td align="left">返回一个日期/时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td align="left">DATEDIFF(date1, date2)</td>
<td align="left">返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody></table>
<p>案例：查询所有员工的入职天数，并根据入职时间倒叙排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name, datediff(curdate(), entrydate) as dates from emp order by dates desc;</span><br></pre></td></tr></table></figure>

<h5 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a><strong>流程函数</strong></h5><p>常用流程函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IF(value, t, f)</td>
<td align="left">如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td align="left">IFNULL(value1, value2)</td>
<td align="left">如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td align="left">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td align="left">如果val1为true，返回res1，… 否则返回default默认值</td>
</tr>
<tr>
<td align="left">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td align="left">如果expr的值等于val1，返回res1，… 否则返回default默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select    name,    if(age between 14 and 28, &#x27;青年&#x27;,&#x27;其他&#x27;) from emp;</span><br><span class="line">select    name,    (case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27; from employee;</span><br></pre></td></tr></table></figure>

<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h4><p>约束是作用于表中字段上的，用于限制存储在表中的数据。目的是保证数据中数据的正确、有效性和完整性。</p>
<p>可以在创建表/修改表的时候添加约束。</p>
<p>常见约束：</p>
<table>
<thead>
<tr>
<th align="left">约束</th>
<th align="left">描述</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">非空约束</td>
<td align="left">限制该字段的数据不能为null</td>
<td align="left">NOT NULL</td>
</tr>
<tr>
<td align="left">唯一约束</td>
<td align="left">保证该字段的所有数据都是唯一、不重复的</td>
<td align="left">UNIQUE</td>
</tr>
<tr>
<td align="left">主键约束</td>
<td align="left">主键是一行数据的唯一标识，要求非空且唯一</td>
<td align="left">PRIMARY KEY（自增：AUTO_INCREMENT）</td>
</tr>
<tr>
<td align="left">默认约束</td>
<td align="left">保存数据时，如果未指定该字段的值，则采用默认值</td>
<td align="left">DEFAULT</td>
</tr>
<tr>
<td align="left">检查约束（8.0.1版本后）</td>
<td align="left">保证字段值满足某一个条件</td>
<td align="left">CHECK</td>
</tr>
<tr>
<td align="left">外键约束</td>
<td align="left">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td align="left">FOREIGN KEY</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user(    </span><br><span class="line">id int primary key auto_increment comment &#x27;主键id&#x27;,    </span><br><span class="line">name varchar(10) not null unique comment &#x27;姓名&#x27;,    </span><br><span class="line">age int check(age between 0 and 120) comment &#x27;年龄&#x27;,    </span><br><span class="line">status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;,    </span><br><span class="line">gender char(1) comment &#x27;性别&#x27; </span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>



<h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a><strong>外键约束</strong></h5><p>外键约束是用来让两个表的数据之间建立连接，从而保证数据的一致性和完整性。</p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20221009164627230.png" alt="image-20221009164627230"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 在创建表时添加外键 </span><br><span class="line">CREATE TABLE 表名(    </span><br><span class="line">字段名 字段类型, </span><br><span class="line">   ...    </span><br><span class="line">[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"> -- 为表补上外键</span><br><span class="line"> ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名); </span><br><span class="line"></span><br><span class="line">-- 删除外键 </span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure>

<p>案例：为 emp 表补上外键，dept_id 关联 dep 中的 id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add constraint fk_emp_dept_id foreign key dept_id references dep(id);</span><br></pre></td></tr></table></figure>

<p><strong>删除/更新行为</strong></p>
<p>表添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。有以下常见的几种：</p>
<h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h5><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p>
<p><strong>一对多</strong></p>
<p>案例：部门与员工</p>
<p>关系：一个部门对应多个员工，一个员工对应一个部门</p>
<p>实现：在多的一方建立外键，指向一的一方的主键</p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20221009165506573.png" alt="image-20221009165506573"></p>
<p><strong>多对多</strong></p>
<p>案例：学生与课程</p>
<p>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修</p>
<p>实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20221009165521388.png" alt="image-20221009165521388"></p>
<p><strong>一对一</strong></p>
<p>案例：用户与用户详情</p>
<p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</p>
<p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20221009165536289.png" alt="image-20221009165536289"></p>
<h5 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h5><p>指的是从多表中查询出想要的数据。</p>
<p><strong>笛卡尔积</strong>：笛卡尔乘积是指在数学中，两个集合 A 集合和 B 集合的所有组合情况。(在多表查询时，需要消除无效的笛<br>卡尔积)</p>
<p>例如：使用 <code>select * from employee, dept;</code> 查询出来的结果是两个表的乘积。</p>
<p><strong>消除笛卡尔积</strong>：<code>select * from employee, dept where employee.dept = dept.id;</code></p>
<p>在进行多表查询测试之前，我们先准备好数据表。</p>
<details>
<summary>先准备好数据表</summary>
<br>
展开
<pre><code> 
create table dept(    
id   int auto_increment comment 'ID' primary key,   
 name varchar(50) not null comment '部门名称' 
)comment '部门表'; 
create table emp(   
 id  int auto_increment comment 'ID' primary key,    
name varchar(50) not null comment '姓名',    age  int comment '年龄',    
job varchar(20) comment '职位',    
salary int comment '薪资',    
entrydate date comment '入职时间',    
managerid int comment '直属领导ID',    
dept_id int comment '部门ID' 
)comment '员工表';
 -- 添加外键 
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);
 INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部');
 INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id) VALUES            (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),             (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),            (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),            (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),            (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),            (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),             (7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),            (8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),            (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),             (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),            (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),            (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),            (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),             (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),            (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),            (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),            (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null); 
 </code></pre> 
</details>


<p><strong>内连接查询</strong>    </p>
<p>内连接查询的是两张表交集的部分。</p>
<p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p>
<p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p>
<p><strong>显式性能比隐式高</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询每一个员工的姓名，及关联的部门的名称（隐式内连接查询）</span><br><span class="line"> select emp.name, dept.name from emp, dep where emp.dept_id = dept.id; select e.name, d.name from emp e, dep d where e.dept_id = d.id; </span><br><span class="line">-- 查询每一个员工的姓名，及关联的部门的名称（显式内连接） </span><br><span class="line">select emp.name, dept.name from emp inner join dept on emp.dept_id = dept.id; select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<p><strong>外连接查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询emp表中的所有数据和对应的部门信息（左外连接） </span><br><span class="line">select e.*, d.* from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line"> -- 查询dept表中的所有数据和对应的员工信息（右外连接） </span><br><span class="line">select d.name, e.* from emp e right join dept d on e.dept_id = d.id;</span><br><span class="line"> -- 以上可以看到，左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</span><br></pre></td></tr></table></figure>

<p><strong>自连接查询</strong></p>
<p>自连接查询指的是于自身的连接查询，把自身当作另一个表，所以要求<strong>必须使用表别名</strong>，<strong>自连接查询可以是内连接查询或者外连接查询。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工及其领导 </span><br><span class="line">select a.name &#x27;员工&#x27;, b.name &#x27;领导&#x27; from emp a, emp b where a.managerid = b.id;</span><br><span class="line"> -- 查询所有员工emp及其领导的名字，如果员工没有领导，也需要查询出来 </span><br><span class="line">select a.*, b.name &#x27;领导&#x27; from emp a left join emp b on a.managerid = b.id;</span><br></pre></td></tr></table></figure>

<p><strong>联合查询union</strong></p>
<p>联合查询就是把多次查询的结果合并，形成一个新的查询集。<strong>联合查询比使用or效率高，不会使索引失效。</strong>对于联合查询，多张表的列数必须保持一致，字段类型也必须保持一段。union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ... </span><br><span class="line">UNION [ALL] </span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure>

<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>SQL 语句中嵌套 SELECT 语句，称谓嵌套查询，又称子查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</span><br></pre></td></tr></table></figure>

<p><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
<h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><p>子查询返回的结果是单个值（数字、字符串、日期等）。</p>
<p>常用操作符：<code>- &lt; &gt; &gt; &gt;= &lt; &lt;=</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部所有员工 </span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line"> -- 根据销售部部门ID，查询员工信息 </span><br><span class="line">select * from emp where dept = 4; </span><br><span class="line">-- 合并成标量子查询 </span><br><span class="line">select * from emp where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"> -- 查询李白入职以后的新入职员工信息</span><br><span class="line"> select * from emp where entrydate &gt; (select entrydate from employee where name = &#x27;李白&#x27;);</span><br></pre></td></tr></table></figure>

<h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><p>返回的结果是一列（可以是多行）。</p>
<p>常用操作符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IN</td>
<td align="left">在指定的集合范围内，多选一</td>
</tr>
<tr>
<td align="left">NOT IN</td>
<td align="left">不在指定的集合范围内</td>
</tr>
<tr>
<td align="left">ANY</td>
<td align="left">子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td align="left">SOME</td>
<td align="left">与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td align="left">ALL</td>
<td align="left">子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息 </span><br><span class="line">select * from emp where dept_id in(select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;); </span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息 </span><br><span class="line">select * from emp where salary &gt; all(select salary from emp where dept_id = (select id from dept where name = &#x27;财务部&#x27;)); </span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line"> select * from emp where salary &gt; any(select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure>

<h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><p>返回的结果是一行（可以是多列）。</p>
<p>常用操作符：<code>=, &lt;, &gt;, IN, NOT IN</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与李白的薪资及直属领导相同的员工信息 </span><br><span class="line">select * from emp where (salary, manager) = (12500, 1); </span><br><span class="line">select * from emp where (salary, manager) = (select salary, manager from emp where name = &#x27;李白&#x27;);</span><br></pre></td></tr></table></figure>

<h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><p>返回的结果是多行多列<br>常用操作符：IN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工 </span><br><span class="line">select * from emp where (job, salary) in (select job, salary from emp where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;); </span><br><span class="line">-- 查询入职日期是2022-01-01之后的员工，及其部门信息 </span><br><span class="line">select e.*, d.* from (select * from emp where entrydate &gt; &#x27;2022-01-01&#x27;) as e left join dept as d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>



<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求</p>
<p><strong>这些操作要么同时成功，要么同时失败。</strong></p>
<p>默认 MysQL 的事务是自动提交的，当执行一条 DML 语句，MySQL 会立即隐式地提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务提交方式 </span><br><span class="line">SELECT @@AUTOCOMMIT; </span><br><span class="line">-- 设置事务提交方式，1 为自动提交，0 为手动提交，该设置只对当前会话有效 </span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line"> -- 提交事务</span><br><span class="line"> COMMIT; </span><br><span class="line">-- 回滚事务 ROLLBACK;</span><br></pre></td></tr></table></figure>

<p><strong>第二种</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务： START TRANSACTION 或 BEGIN TRANSACTION; </span><br><span class="line">-- 提交事务： </span><br><span class="line">COMMIT; </span><br><span class="line">-- 回滚事务： </span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h4 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h4><p>事物的四大特性 ACID</p>
<ul>
<li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态。</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><strong>并发事务问题</strong></p>
<table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">脏读</td>
<td align="left">一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td align="left">不可重复读</td>
<td align="left">一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td align="left">幻读</td>
<td align="left">一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存</td>
</tr>
</tbody></table>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>MySQL 默认的事务隔离级别是 Repeatable Read</p>
<p>Oracle 默认的事务隔离级别是 Read committed</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read uncommitted</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">Read committed</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">Repeatable Read(默认)</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
<p>√ 表示在当前隔离级别下该问题会出现，</p>
<p>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务隔离级别：</span><br><span class="line"> SELECT @@TRANSACTION_ISOLATION; </span><br><span class="line">-- 设置事务隔离级别： </span><br><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</span><br><span class="line"> -- SESSION 是会话级别，表示只针对当前会话有效 </span><br><span class="line">-- GLOBAL 表示对所有会话有效</span><br></pre></td></tr></table></figure>



<p><strong>存储引擎</strong></p>
<p><strong>MySQL体系结构</strong></p>
<p><img src="https://gitee.com/june2009/pic_oss/raw/master/imgs/image-20221009173412111.png" alt="image-20221009173412111"></p>
<h5 id="三种存储引擎"><a href="#三种存储引擎" class="headerlink" title="三种存储引擎"></a>三种存储引擎</h5><p>存储引擎是 MySQL 数据库的核心，我们需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。<strong>存储引擎是基于表的，而不是基于库的</strong>，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。</p>
<p>因此在建表时指定存储引擎的 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ] ,</span><br><span class="line">    ......</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure>



<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是 MySQL 默认的存储引擎。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>DML 操作遵循 ACID 模型，<strong>支持事务</strong>；</li>
<li><strong>行级锁</strong>，提高并发访问性能；</li>
<li><strong>支持外键</strong> FOREIGN KEY 约束，保证数据的完整性和正确性；</li>
</ul>
<h5 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h5><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
<th align="left">Memory</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储限制</td>
<td align="left">64TB</td>
<td align="left">有</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left">事务安全</td>
<td align="left">支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">锁机制</td>
<td align="left">行锁</td>
<td align="left">表锁</td>
<td align="left">表锁</td>
</tr>
<tr>
<td align="left">B+tree索引</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">Hash索引</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">全文索引</td>
<td align="left">支持（5.6版本之后）</td>
<td align="left">支持</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">空间使用</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">N/A</td>
</tr>
<tr>
<td align="left">内存使用</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">批量插入速度</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">支持外键</td>
<td align="left">支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>InnoDB 和 MyISAM 存储引擎的主要区别：</p>
<ol>
<li><p>InnoDB 支持事物，锁是行级锁，支持外键</p>
</li>
<li><p>MyISAM 不支持事物，锁是表级锁，不支持外键</p>
</li>
<li><p>另外，InnoDB 占用内存空间大，插入速度低；MyISAM 占用内存空间小，插入速度高</p>
<h5 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h5><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li><strong>InnoDB</strong>：是 MySQL 的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。</li>
<li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>Memory：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY 的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li>
</ul>
<p>对于 MySQL 常用的存储引擎还是 InnoDB，因此创建表时不需要我们自定义，默认就是。</p>
<p>对于 MyISAM，市面上有了 MongoDB；对于 Memory，市面上有了 Redis。</p>
</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引*"></a><em>索引</em>*</h3><h5 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a><strong>索引概述</strong></h5><p>索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">提高数据检索效率，降低数据库的 IO 成本</td>
<td align="left">索引列也是要占用空间</td>
</tr>
<tr>
<td align="left">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td>
<td align="left">索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">索引结构</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B+Tree</td>
<td align="left">最常见的索引类型，大部分引擎都支持 B+Tree 索引</td>
</tr>
<tr>
<td align="left">Hash</td>
<td align="left">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td align="left">R-Tree(空间索引)</td>
<td align="left">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td align="left">Full-Text(全文索引)</td>
<td align="left">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene、Solr、ES</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205210020765.png">https://cdn.xn2001.com/img/2022/202205210020765.png</a></p>
<p><strong>索引的存储类型</strong></p>
<p>索引是在存储引擎中实现的，因此每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。</p>
<p>根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p>
<p>大多数存储引擎有更高的限制。</p>
<p>MySQL中索引的存储类型有两种：BTREE和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=HASH&spm=1001.2101.3001.7020">HASH</a>，具体和表的存储引擎相关</p>
<p>1、MYISAM和InnoDB存储引擎只支持BTREE索引<br>2、MEMORY和HEAP存储引擎可以支持HASH和BTREE索引</p>
<h5 id="为什么要用索引？"><a href="#为什么要用索引？" class="headerlink" title="为什么要用索引？"></a>为什么要用索引？</h5><p>使用索引后减少了存储引擎需要扫描的数据量，加快查询速度<br>索引可以把随机I/O变为顺序I/O<br>索引可以帮助我们对所搜结果进行排序以避免使用磁盘临时表<br>Mysql支持的索引类型：</p>
<p>B-TREE索引与HASH索引，两者有不同的使用场景，下面来简单剖析下这两者的区别。</p>
<p><strong>B-TREE索引</strong><br>B-TREE索引的特点<br>B-TREEB-TREE以<strong>B+树结构存储数据</strong>，大大加快了数据的查询速度<br>B-TREE索引在范围查找的SQL语句中更加适合（顺序存储）</p>
<p>B-TREE索引使用场景<br>全值匹配的查询SQL，如 where act_id= ‘1111_act’<br>联合索引汇中匹配到最左前缀查询，如联合索引 KEY idx_actid_name(act_id,act_name) USING BTREE，只要条件中使用到了联合索引的第一列，就会用到该索引，但如果查询使用到的是联合索引的第二列act_name，该SQL则便无法使用到该联合索引（注：覆盖索引除外）<br>匹配模糊查询的前匹配，如where act_name like ‘11_act%’<br>匹配范围值的SQL查询，如where act_date > ‘9865123547215’（not in和<>无法使用索引）<br>覆盖索引的SQL查询，就是说select出来的字段都建立了索引<br>————————————————<br><strong>HASH索引</strong><br>HASH的特点<br>Hash索引<strong>基于Hash表</strong>实现，只有查询条件精确匹配Hash索引中的所有列才会用到hash索引<br>存储引擎会为Hash索引中的每一列都计算hash码，Hash索引中存储的即hash码，所以每次读取都会进行两次查询<br>Hash索引无法用于排序<br>Hash不适用于区分度小的列上，如性别字段<br>————————————————</p>
<h6 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h6><p>B-Tree 是一种多叉路衡查找树，相对于二叉树，B-Tree 每个节点可以有多个分支，即多叉。</p>
<p>以一颗最大度数（max-degree）为 5 的 B-Tree 为例，那这个 B-Tree 每个节点最多存储 4 个 key，一共 5 个指针。</p>
<p>动画演示地址：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
<h6 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h6><p>MySQL 中除了支持 B+Tree 索引，还支持一种索引类型，Hash 索引。</p>
<p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为hash碰撞），可以通过链表来解决。</p>
<h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主键索引</td>
<td align="left">针对于表中主键创建的索引</td>
<td align="left">默认自动创建，只能有一个</td>
<td align="left">PRIMARY</td>
</tr>
<tr>
<td align="left">唯一索引</td>
<td align="left">避免同一个表中某数据列中的值重复</td>
<td align="left">可以有多个</td>
<td align="left">UNIQUE</td>
</tr>
<tr>
<td align="left">常规索引</td>
<td align="left">快速定位特定数据</td>
<td align="left">可以有多个</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">全文索引</td>
<td align="left">全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td align="left">可以有多个</td>
<td align="left">FULLTEXT</td>
</tr>
</tbody></table>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">聚集索引（Clustered Index）</td>
<td align="left">将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td align="left"><strong>必须有，而且只有一个</strong></td>
</tr>
<tr>
<td align="left">二级索引（Secondary Index）</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p>上面说了，聚集索引必须要有，那么聚集索引该是啥呢，规则如下</p>
<ol>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ol>
<p>找到合适的聚集索引后，剩下的索引都为二级索引。如下图，聚集索引的叶子节点下挂的是这一行的数据。而二级索引的叶子节点下挂的是该字段值对应的主键值。</p>
<h5 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h5><p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX 索引名 <span class="keyword">ON</span> 表名 (字段名, ...);</span><br></pre></td></tr></table></figure>

<p>则创建的是常规索引</p>
<p>查看索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表名;</span><br></pre></td></tr></table></figure>

<details>
<summary>练习</summary>
\```{r}
-- 查看索引
-- show INDEX from tb_user;
    --  创建索引
-- CREATE [ UNIQUE | FULLTEXT ] INDEX 索引名 ON 表名 (字段名, ...);
    -- 删除索引
-- DROP INDEX idx_user_email ON tb_user;
-- name 字段为姓名字段，该字段的值可能会重复，为该字段创建索引
-- CREATE INDEX  index_user_name ON tb_user (NAME);

<p>-- phone 手机号字段的值非空，且唯一，为该字段创建唯一索引<br>-- CREATE UNIQUE INDEX index_user_phone ON tb_user(phone);</p>
<p>-- 为 profession, age, status 创建联合索引<br>-- CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</p>
<p>-- 为 email 建立合适的索引来提升查询效率<br>-- CREATE INDEX idx_user_email on tb_user(email);</p>
<p>-- 索引失效，联合索引最左边的列profession不存在<br>-- explain select * from tb_user where status = '0';</p>
<p>-- 索引失效，联合索引最左边的列profession不存在<br>-- EXPLAIN select * from tb_user where age = 31 and status = '0';</p>
<p>-- 索引生效<br>-- EXPLAIN select * from tb_user where profession = '软件工程';</p>
<p>-- 索引失效。<br>-- explain select * from tb_user where substring(phone, 10, 2) = '15';</p>
<p>-- 此处phone是字符串类型，由于值没有加引号导致索引失效<br>-- EXPLAIN select * from tb_user where phone = '17799990015';</p>
<p>-- 前缀索引<br>-- create index 索引名 on 表名(字段名(长度));<br>-- 例如，为 tb_user 表的 email 字段建立长度为 5 的前缀索引。<br>-- CREATE INDEX idx_user_pre_email ON tb_user (email(5));</p>
<p>-- select count(distinct email) / count(*) from tb_user ;</p>
<p>-- SELECT @@have_profiling; </p>
<p>-- 添加外键<br>-- ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);<br>-- 案例：为 emp 表补上外键，dept_id 关联 dep 中的 i<br>--  ALTER TABLE emp add CONSTRAINT fk_emp_dep_id FOREIGN KEY (dept_id) REFERENCES dept (id);</p>
<p>-- 删除外键<br>-- ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept_id;</p>
<p>```</p>
</details>





<p>1.添加primary key(主键索引)<br>alter   table  表名   add  primary   key(列名);</p>
<p>2.添加unique(唯一索引)<br>alter  table  表名  add  unique(列名);</p>
<p>3.添加index(普通索引)<br>alter  table  表名  add  index  索引名(index_name)  (列名);</p>
<p>4.添加fulltext(全文索引)<br>alter  table  表名  add  fulltext  (列名);</p>
<p>5.添加多列索引<br>alter  table  表名  add  index  索引名(index_name)  (列名1，列名2.......);</p>
<p>当不再需要索引时，可以使用 DROP INDEX 语句 或 ALTER TABLE 语句来对索引进行删除。<br>1.使用 DROP INDEX 语句<br>语法格式：<br>DROP INDEX <索引名> ON <表名><br>————————————————</p>
<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a><strong>SQL性能分析</strong></h3><h5 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h5><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。</p>
<p>通过如下指令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以得知该表是增删改为主，还是查询为主。</p>
<h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10s）的所有SQL语句的日志。</p>
<p>查看慢查询日志开关状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（/etc/my.cnf）中配置如下信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志开关</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 设置慢查询日志的时间为<span class="number">2</span>s，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>s，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>重启 MySQL 服务，日志文件位置：<code>/var/lib/mysql/localhost-slow.log</code></p>
<p>通过慢查询日志，就可以定位出执行效率比较低的 SQL，从而有针对性的进行优化。</p>
<h5 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h5><p>profile 能在做 SQL 优化时帮我们了解时间都耗费在哪里。查看当前 MySQL 是否支持 profile 操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling;  #显示yes代表支持</span><br></pre></td></tr></table></figure>

<h5 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h5><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<p>执行下面的 SQL 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id, profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status, name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status<span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><a href="%5Bhttps://blog.csdn.net/jiadajing267/article/details/81269067?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81269067-blog-113979657.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81269067-blog-113979657.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1%5D(https://blog.csdn.net/jiadajing267/article/details/81269067?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81269067-blog-113979657.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81269067-blog-113979657.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1)">【MySQL优化】——看懂explain</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38975553/article/details/104134587?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-104134587-blog-81269067.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">看explain2</a>  （演示）<strong>建议，建表操作一遍；</strong></p>
<p><strong>重要指标</strong></p>
<p>type列<br>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。</p>
<p>依次从最优到最差分别为：system > const > eq_ref > ref > range > index > ALL</p>
<p>一般来说，得保证查询达到range级别，最好达到ref<br>）</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h3><h5 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h5><p>1.满足业务需求的情况下，尽量降低主键的长度。</p>
<p>2.插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键。</p>
<p>3.尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。</p>
<p>4.业务操作时，避免对主键的修改。</p>
<h5 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h5><p>如果一次性需要插入大批量数据，比如几百万的记录，使用 insert 语句插入性能较低，此时可以使 用MySQL 提供的 load 指令进行插入。可以执行如下指令，将数据脚本文件中的数据加载到表结构中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务端时，加上参数 -–local-infile</span></span><br><span class="line">mysql –<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line"><span class="comment">-- fields terminated by &#x27;,&#x27; 每个字段使用「，」分割</span></span><br><span class="line"><span class="comment">-- lines terminated by &#x27;\n&#x27; 每一行数据使用「换行」分割</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h5><p>在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table IOT）。</p>
<p><strong>ORDER BY优化</strong></p>
<p>由上述的测试，我们得出 order by 优化原则如下</p>
<p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
<p>B. 尽量使用覆盖索引；意思就是查询的字段就是索引字段。不要用 <code>select *</code></p>
<p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC / DESC）</p>
<p>D. 如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 <code>sort_buffer_size</code>（默认 256k）</p>
<p><strong>GROUP BY优化</strong></p>
<p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能</p>
<p>A. 在分组操作时，可以通过索引来提高效率。</p>
<p>B. 在分组操作时，索引的使用也是要满足最左前缀法则的。</p>
<h5 id="COUNT优化"><a href="#COUNT优化" class="headerlink" title="COUNT优化"></a>COUNT优化</h5><p>下面的 SQL 语句，如果数据量很大，在执行 count 操作时，是非常耗时的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>

<p>按照效率排序的话，<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</code>，尽量使用 <code>count(*)</code></p>
<h5 id="UPDATE优化"><a href="#UPDATE优化" class="headerlink" title="UPDATE优化"></a>UPDATE优化</h5><p>我们需要注意一下 UPDATE 语句执行时的注意事项。</p>
<p>当我们在执行修改的 SQL 语句时，会锁定 id 为 1 这一行的数据，其他数据不会锁定，<strong>该操作事务提交之后，行锁释放。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当我们在执行如下 SQL 时，把 name 为 PHP 改为 SpringBoot</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>此时由于 name 字段没有索引，InnoDB 会会从行锁升级为表锁 。</p>
<p>也就是说，InnoDB 的行锁是针对索引加的锁，如果 SQL 操作的字段没有索引，该操作会从行锁升级为表锁，导致整个表在别的线程下无法修改。因此我们在 UPDATE 操作时要注意避免行锁升级为表锁。</p>
<h3 id="mapper-xml使用"><a href="#mapper-xml使用" class="headerlink" title="mapper.xml使用"></a>mapper.xml使用</h3><h5 id="Mapper-xml-中-和-的-区别"><a href="#Mapper-xml-中-和-的-区别" class="headerlink" title="Mapper.xml 中 #{} 和 ${} 的 区别"></a>Mapper.xml 中 #{} 和 ${} 的 区别</h5><p>简单说</p>
<ul>
<li>#{ para } 产生的是 PreparedStatement 的占位符</li>
<li>${ something } 就相当于将字符串插入到 SQL 当中</li>
</ul>
<p>在实际中我们尽可能使用前者而并非后者, 因为前者会对你插入的字符串做个简单的转换，能在一定程度上防止 SQL 注入。</p>
<p>假设我们前端没有做验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM <span class="built_in">test</span> WHERE name = <span class="variable">$&#123;name&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>而有人选择传入参数 'Draper' OR 1=1 那么整体的 SQL 语句就会变成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM <span class="built_in">test</span> WHERE name = <span class="string">&#x27;Draper&#x27;</span> OR 1=1; </span><br></pre></td></tr></table></figure>

<p>那么无论有没有 Draper 他都会检索多条记录。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhjun2016.github.io">ajun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhjun2016.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/">https://zhjun2016.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhjun2016.github.io" target="_blank">逆风而行的蟋蟀</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/23/%E7%89%A9%E8%81%94%E7%BD%91/%E7%89%A9%E8%81%94%E7%BD%91mqtt%E6%90%AD%E5%BB%BA/" title="MQTT研究之路"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MQTT研究之路</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/23/java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微服务</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ajun</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">MySQL学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.</span> <span class="toc-text">图形管理界面工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%86%B5"><span class="toc-number">1.2.</span> <span class="toc-text">概况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SQL"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">SQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">SQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DDL"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.1.1.</span> <span class="toc-text">数据库操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.1.2.</span> <span class="toc-text">数据表操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DML"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">DML</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DQL"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">DQL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.0.3.1.</span> <span class="toc-text">基础查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.0.3.2.</span> <span class="toc-text">条件查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.0.3.3.</span> <span class="toc-text">聚合查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DQL%E7%BB%83%E4%B9%A0"><span class="toc-number">1.3.0.3.4.</span> <span class="toc-text">DQL练习</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DCL"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">DCL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.0.4.1.</span> <span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.0.4.2.</span> <span class="toc-text">权限管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">数值函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">流程函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">多表查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">多表查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.4.1.</span> <span class="toc-text">标量子查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.4.2.</span> <span class="toc-text">列子查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.4.3.</span> <span class="toc-text">行子查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.4.4.</span> <span class="toc-text">表子查询</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1ACID"><span class="toc-number">1.4.1.</span> <span class="toc-text">事务ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">三种存储引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">InnoDB</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">存储引擎对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">存储引擎的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.</span> <span class="toc-text">索引*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">为什么要用索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.5.0.2.1.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hash"><span class="toc-number">1.5.0.2.2.</span> <span class="toc-text">Hash</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">索引语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">SQL执行频率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#profile%E8%AF%A6%E6%83%85"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">profile详情</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">explain执行计划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">索引设计原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">大批量插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">数据组织方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COUNT%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">COUNT优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UPDATE%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.0.5.</span> <span class="toc-text">UPDATE优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapper-xml%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">mapper.xml使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mapper-xml-%E4%B8%AD-%E5%92%8C-%E7%9A%84-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">Mapper.xml 中 #{} 和 ${} 的 区别</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/android%20view%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%8C%E5%9D%90%E6%A0%87/" title="android view树结构、坐标">android view树结构、坐标</a><time datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/Chocolatey%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="Chocolatey介绍、安装、使用">Chocolatey介绍、安装、使用</a><time datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/c++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="c++语言学习">c++语言学习</a><time datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/" title="hexo博客创建使用">hexo博客创建使用</a><time datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/git%E4%BD%BF%E7%94%A8%E6%8F%90%E4%BA%A4/" title="git安装使用">git安装使用</a><time datetime="2023-04-23T02:26:53.000Z" title="发表于 2023-04-23 10:26:53">2023-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ajun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>